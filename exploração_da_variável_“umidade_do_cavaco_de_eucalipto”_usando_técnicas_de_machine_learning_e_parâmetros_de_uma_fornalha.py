# -*- coding: utf-8 -*-
"""Exploração da variável “umidade do cavaco de eucalipto” usando técnicas de machine learning e parâmetros de uma fornalha

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/166zXgtv2H9ISlKG-2EfKhHvJtP4JK8n4

Importando os dados e instalando pacotes
"""

!pip install pandas
!pip install numpy

import pandas as pd

df = pd.read_excel("Base de dados v2.xlsx", sheet_name="Base de dados v2", index_col=0)

print(df)

"""Filtrar os dados com base na variável resposta acima de 15 (valores abaixo desse número são vistos na prática como incoerentes)"""

df_filtrado = df.loc[df['Variável resposta'] > 15]
df_total = df_filtrado.dropna()
df_total

"""Definir os parâmetros que são de combustão e os que são dos gases quentes"""

comb = ["Parâmetro 5","Parâmetro 6","Parâmetro 9","Parâmetro 10","Parâmetro 11","Parâmetro 12",
        "Parâmetro 15","Parâmetro 16","Parâmetro 17","Parâmetro 18","Parâmetro 19","Parâmetro 20",
        "Parâmetro 22","Parâmetro 23","Parâmetro 26"]
gases = ["Parâmetro 1","Parâmetro 2","Parâmetro 3","Parâmetro 4","Parâmetro 7","Parâmetro 8",
         "Parâmetro 13","Parâmetro 14","Parâmetro 21","Parâmetro 24","Parâmetro 25","Parâmetro 27"]
print("comb =", comb)
print("gases =", gases)

"""Separar os dois data frames e a variável resposta"""

df_comb = df_total.loc[:,comb]
df_gases = df_total.loc[:,gases]

umidade = ["Variável resposta"]

df_umidade = df_total.loc[:,umidade]

#df_comb
df_gases
#df_umidade

"""Avaliando a variável resposta"""

!pip install seaborn matplotlib
import seaborn as sns
import matplotlib.pyplot as plt

sns.boxplot(y=df_umidade['Variável resposta'], color = '#FF99AA')
plt.title('Boxplot da Variável Umidade')
plt.show()

print(df_umidade['Variável resposta'].describe())

from matplotlib import pyplot as plt
df_umidade['Variável resposta'].plot(kind='hist', bins=20, title='Variável resposta', color = '#BA1E1E')
plt.gca().spines[['top', 'right',]].set_visible(False)

plt.plot(df_umidade['Variável resposta'], color = '#80006A')
plt.xlabel('Data')
plt.ylabel('Umidade')
plt.title('Série Temporal da Variável Umidade')
plt.show()

plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_umidade.index, y=df_umidade['Variável resposta'])
plt.xlabel('Data')
plt.ylabel('Variável Resposta')
plt.title('Gráfico de Dispersão da Variável Resposta')
plt.show()

"""Utilizando o stepwise backwards para identificar as variáveis mais significativas na combustão"""

import statsmodels.api as sm

X = df_comb
y = df_umidade

# Adicionando uma constante a variável independente
X = sm.add_constant(X)

# Ajustando um modelo inicial
model = sm.OLS(y, X).fit()

# Aplicando a seleção por stepwise
def backward_elimination(data, target,significance_level = 0.05):
    features = data.columns.tolist()
    while(len(features)>0):
        features_with_constant = sm.add_constant(data[features])
        p_values = sm.OLS(target, features_with_constant).fit().pvalues[1:]
        max_p_value = p_values.max()
        if(max_p_value >= significance_level):
            excluded_feature = p_values.idxmax()
            features.remove(excluded_feature)
        else:
            break
    return features

stepwise_comb = backward_elimination(X, y)
stepwise_comb.remove('const')

print('Variáveis selecionadas: ', stepwise_comb)

"""Mesmo processo para os gases quentes"""

import statsmodels.api as sm

X = df_gases
y = df_umidade

# Adicionando uma constante a variável independente
X = sm.add_constant(X)

# Ajustando um modelo inicial
model2 = sm.OLS(y, X).fit()

# Aplicando a seleção por stepwise
def backward_elimination(data, target,significance_level = 0.05):
    features = data.columns.tolist()
    while(len(features)>0):
        features_with_constant = sm.add_constant(data[features])
        p_values = sm.OLS(target, features_with_constant).fit().pvalues[1:]
        max_p_value = p_values.max()
        if(max_p_value >= significance_level):
            excluded_feature = p_values.idxmax()
            features.remove(excluded_feature)
        else:
            break
    return features

stepwise_gases = backward_elimination(X, y)
stepwise_gases.remove('const')

print('Variáveis selecionadas: ', stepwise_gases)

"""Criando banco de dados apenas com as variáveis selecionadas no stepwise (um com os valores da combustão e outro só com os gases quentes)"""

import seaborn as sns
import matplotlib.pyplot as plt

# Combinar os bancos de dados do resultado do stepwise e a variável resposta
df_stepwise1 = df_comb.loc[:, stepwise_comb]
df_stepwise_comb = pd.concat([df_stepwise1, df_umidade], axis=1)

df_stepwise2 = df_gases.loc[:, stepwise_gases]
df_stepwise_gases = pd.concat([df_stepwise2, df_umidade], axis=1)

df_total = pd.concat([df_stepwise_comb, df_stepwise2], axis=1)

#print(df_stepwise_comb)
#print(df_stepwise_gases)
#print(df_total)

df_total

"""Fazer um heatmap para enxergar as correlações entre as variáveis e a resposta



"""

# Calcular a matriz de correlação

matrix_corre = df_stepwise_comb.corr()

# Criando o heatmap
plt.figure(figsize=(9, 5))
sns.heatmap(matrix_corre, annot=True, cmap='coolwarm')
plt.title('Heatmap de Correlação')
plt.show()

# Calcular a matriz de correlação

matrix_corre = df_stepwise_gases.corr()

# Criando o heatmap
plt.figure(figsize=(9, 5))
sns.heatmap(matrix_corre, annot=True, cmap='coolwarm')
plt.title('Heatmap de Correlação')
plt.show()

"""Fazendo gráficos de dispersão da variável resposta e os 5 parâmetros mais influentes"""

correlacoes_gases = df_stepwise_gases.corr()['Variável resposta'].sort_values(ascending=False)
correlacoes_gases = correlacoes_gases.drop('Variável resposta')
print(correlacoes_gases)
correlacoes_comb = df_stepwise_comb.corr()['Variável resposta'].sort_values(ascending=False)
correlacoes_comb = correlacoes_comb.drop('Variável resposta')
print(correlacoes_comb)

#Parâmetro 4
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_stepwise_gases['Parâmetro 4'], y=df_stepwise_gases['Variável resposta'])
plt.xlabel('Parâmetro 4')
plt.ylabel('Variável Resposta')
plt.title('Gráfico de Dispersão da Variável Resposta em relação ao parâmetro 4')
plt.show()

#Parâmetro 6
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_stepwise_comb['Parâmetro 6'], y=df_stepwise_comb['Variável resposta'])
plt.xlabel('Parâmetro 6')
plt.ylabel('Variável Resposta')
plt.title('Gráfico de Dispersão da Variável Resposta em relação ao parâmetro 6')
plt.show()

#Parâmetro 8
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_stepwise_gases['Parâmetro 8'], y=df_stepwise_gases['Variável resposta'])
plt.xlabel('Parâmetro 8')
plt.ylabel('Variável Resposta')
plt.title('Gráfico de Dispersão da Variável Resposta em relação ao parâmetro 8')
plt.show()

#Parâmetro 13
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_stepwise_gases['Parâmetro 13'], y=df_stepwise_gases['Variável resposta'])
plt.xlabel('Parâmetro 13')
plt.ylabel('Variável Resposta')
plt.title('Gráfico de Dispersão da Variável Resposta em relação ao parâmetro 13')
plt.show()

#Parâmetro 24
plt.figure(figsize=(8, 6))
sns.scatterplot(x=df_stepwise_gases['Parâmetro 24'], y=df_stepwise_gases['Variável resposta'])
plt.xlabel('Parâmetro 24')
plt.ylabel('Variável Resposta')
plt.title('Gráfico de Dispersão da Variável Resposta em relação ao parâmetro 24')
plt.show()

"""Testando análise de PCA"""

!pip install factor_analyzer
from factor_analyzer import FactorAnalyzer
from factor_analyzer.factor_analyzer import calculate_bartlett_sphericity

# Teste de Esfericidade de Bartlett

bartlett, p_value = calculate_bartlett_sphericity(df_total)
print(f'Qui² Bartlett: {round(bartlett, 2)}')
print(f'p-valor: {round(p_value, 4)}')

#%% Definindo a PCA (procedimento inicial com todos os fatores possíveis)

fa = FactorAnalyzer(n_factors=12, method='principal', rotation=None).fit(df_total)

#%% Obtendo os eigenvalues (autovalores)

autovalores = fa.get_eigenvalues()[0]

print(autovalores)

#%% Eigenvalues, variâncias e variâncias acumuladas

autovalores_fatores = fa.get_factor_variance()

tabela_eigen = pd.DataFrame(autovalores_fatores)
tabela_eigen.columns = [f"Fator {i+1}" for i, v in enumerate(tabela_eigen.columns)]
tabela_eigen.index = ['Autovalor','Variância', 'Variância Acumulada']
tabela_eigen = tabela_eigen.T

print(tabela_eigen)

#%% Gráfico da variância acumulada dos componentes principais

plt.figure(figsize=(12,8))
ax = sns.barplot(x=tabela_eigen.index, y=tabela_eigen['Variância'], data=tabela_eigen, palette='rocket')
ax.bar_label(ax.containers[0])
plt.title("Fatores Extraidos", fontsize=16)
plt.xlabel(f"{tabela_eigen.shape[0]} fatores que explicam {round(tabela_eigen['Variância'].sum()*100,2)}% da variância", fontsize=12)
plt.ylabel("Porcentagem de variância explicada", fontsize=12)
plt.show()

#%% Determinando as cargas fatoriais

cargas_fatoriais = fa.loadings_

tabela_cargas = pd.DataFrame(cargas_fatoriais)
tabela_cargas.columns = [f"Fator {i+1}" for i, v in enumerate(tabela_cargas.columns)]
tabela_cargas.index = df_total.columns

print(tabela_cargas)

#%% Determinando as comunalidades

comunalidades = fa.get_communalities()

tabela_comunalidades = pd.DataFrame(comunalidades)
tabela_comunalidades.columns = ['Comunalidades']
tabela_comunalidades.index = df_total.columns

print(tabela_comunalidades)

# Extração dos fatores para as observações do banco de dados

fatores = pd.DataFrame(fa.transform(df_total))
fatores.columns =  [f"Fator {i+1}" for i, v in enumerate(fatores.columns)]

# Adicionando os fatores ao banco de dados

df_pca = pd.concat([df_total.reset_index(drop=True), fatores], axis=1)
df_pca

# Identificando os scores fatoriais

scores = fa.weights_

tabela_scores = pd.DataFrame(scores)
tabela_scores.columns = [f"Fator {i+1}" for i, v in enumerate(tabela_scores.columns)]
tabela_scores.index = df_total.columns

print(tabela_scores)

